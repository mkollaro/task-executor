#!/usr/bin/env python
#
# Copyright (c) 2013 Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#           http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Dynamically load a Python module, run taskrunner with a pipeline from it.

The task configurations (or pipelines, or a combination of them) specified on
the command line will be read from the dynamically loaded Python module, put
into a pipeline and executed by taskrunner.
"""

import imp
from optparse import OptionParser

import taskrunner


def parse_args():
    """Get positional arguments and options.

    Prints a help message if the arguments are incorrect.
    :returns: filepath, task_names, options
    """
    parser = OptionParser(usage="%prog FILEPATH TASKS [OPTIONS]")
    choices = ["yes", "no", "only"]
    parser.add_option("-c", "--cleanup", dest="cleanup",
                      type="choice", choices=choices, default="yes",
                      help="Select one of %s. If 'yes', execute the run part"
                           " of the tasks, then the cleanups in reverse order."
                           " If 'no', don't run the cleanups."
                           " If 'only', don't execute the runs, only the"
                           " cleanups. Default is 'yes'" % choices)

    options, positional_arguments = parser.parse_args()
    if len(positional_arguments) < 2:
        print "Not enough arguments"
        parser.print_help()
        exit(1)
    filepath = positional_arguments[0]
    task_names = positional_arguments[1:]

    return filepath, task_names, options


def import_python_file(filepath):
    """Return dynamically imported python source."""
    return imp.load_source("dynamically_imported", filepath)


def get_pipeline(definitions, var_names):
    """Get a list of task configurations from the definitions module.

    Find var_names in the definitions module and add them to the pipeline.
    :returns: a list of dictionaries (aka task configurations)
    """
    pipeline = []
    for name in var_names:
        var = vars(definitions)[name]
        if type(var) is list or type(var) is tuple:
            pipeline += var
        else:
            pipeline.append(var)
    return pipeline


if __name__ == '__main__':
    filepath, task_names, options = parse_args()

    definitions = import_python_file(filepath)
    pipeline = get_pipeline(definitions, task_names)

    taskrunner.execute(pipeline)
